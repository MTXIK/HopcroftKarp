package main

import (
	"encoding/binary" // Для работы с бинарными данными
	"flag"            // Для парсинга аргументов командной строки
	"fmt"             // Для форматированного ввода/вывода
	"log"             // Для логирования ошибок
	"os"              // Для работы с файловой системой
)

// Функция readGraph читает граф из бинарного файла.
// Вход: имя файла.
// Выход: матрица смежности, размер графа, ошибка (если есть).
func readGraph(filename string) ([][]int, int, error) {
	// Открываем файл для чтения.
	file, err := os.Open(filename)
	if err != nil {
		return nil, 0, err // Возвращаем ошибку, если не удалось открыть файл.
	}
	defer file.Close() // Закрываем файл при выходе из функции.

	var size int16
	// Читаем первый int16 из файла, который представляет размер матрицы.
	err = binary.Read(file, binary.LittleEndian, &size)
	if err != nil {
		return nil, 0, err // Возвращаем ошибку, если чтение не удалось.
	}

	n := int(size) // Преобразуем размер к типу int для удобства.
	// Создаём двумерный срез для хранения матрицы смежности.
	matrix := make([][]int, n)
	for i := 0; i < n; i++ {
		matrix[i] = make([]int, n) // Инициализируем каждую строку матрицы.
		for j := 0; j < n; j++ {
			var val int16
			// Читаем следующий int16 из файла и сохраняем его в матрицу.
			err = binary.Read(file, binary.LittleEndian, &val)
			if err != nil {
				return nil, 0, err // Возвращаем ошибку, если чтение не удалось.
			}
			matrix[i][j] = int(val) // Преобразуем int16 в int для удобства дальнейшей обработки.
		}
	}

	return matrix, n, nil // Возвращаем матрицу, размер и отсутствие ошибки.
}

// Функция isBipartite проверяет, является ли граф двудольным.
// Вход: матрица смежности, размер графа.
// Выход: булевое значение (является ли граф двудольным), массив цветов вершин.
func isBipartite(graph [][]int, n int) (bool, []int) {
	color := make([]int, n) // Создаём массив цветов для вершин.
	for i := 0; i < n; i++ {
		color[i] = -1 // Инициализируем все вершины без цвета.
	}

	// Проходим по всем вершинам графа.
	for i := 0; i < n; i++ {
		// Если вершина ещё не раскрашена, начинаем BFS из неё.
		if color[i] == -1 {
			queue := []int{i}    // Создаём очередь для BFS и добавляем начальную вершину.
			color[i] = 0         // Раскрашиваем начальную вершину цветом 0.

			// Пока очередь не пуста, продолжаем обход.
			for len(queue) > 0 {
				u := queue[0]   // Берём первый элемент из очереди.
				queue = queue[1:] // Удаляем его из очереди.

				// Проходим по всем вершинам, смежным с u.
				for v := 0; v < n; v++ {
					if graph[u][v] != 0 { // Если есть ребро между u и v.
						if color[v] == -1 { // Если вершина v ещё не раскрашена.
							color[v] = 1 - color[u] // Раскрашиваем её противоположным цветом.
							queue = append(queue, v) // Добавляем v в очередь для дальнейшего обхода.
						} else if color[v] == color[u] {
							// Если соседняя вершина уже раскрашена тем же цветом, граф не двудольный.
							return false, nil
						}
					}
				}
			}
		}
	}
	return true, color // Если не обнаружено конфликтов в раскраске, граф двудольный.
}

// Структура BipartiteMatcher реализует алгоритм Hopcroft-Karp для поиска максимального паросочетания.
type BipartiteMatcher struct {
	graph  [][]int // Матрица смежности двудольного графа.
	pairU  []int   // Пары для левой части графа (U).
	pairV  []int   // Пары для правой части графа (V).
	dist   []int   // Массив расстояний для BFS.
	INF    int     // Представляет "бесконечность" для алгоритма.
}

// Конструктор NewBipartiteMatcher создаёт новый экземпляр BipartiteMatcher.
// Вход: матрица смежности, размер графа.
// Выход: указатель на новый BipartiteMatcher.
func NewBipartiteMatcher(graph [][]int, n int) *BipartiteMatcher {
	return &BipartiteMatcher{
		graph: graph,
		pairU: make([]int, n),       // Инициализируем пары для U.
		pairV: make([]int, n),       // Инициализируем пары для V.
		dist:  make([]int, n+1),     // Массив расстояний с дополнительным элементом для dummy.
		INF:   n + 1,                 // Значение "бесконечности".
	}
}

// Метод bfs выполняет поиск в ширину для построения уровневого графа.
// Вход: массив цветов вершин, размер графа.
// Выход: true, если существует путь увеличения, иначе false.
func (m *BipartiteMatcher) bfs(color []int, n int) bool {
	queue := []int{} // Очередь для BFS.

	// Инициализируем расстояния для всех вершин левой части, которые свободны.
	for u := 0; u < n; u++ {
		if color[u] == 0 && m.pairU[u] == -1 {
			m.dist[u] = 0          // Расстояние до свободной вершины равно 0.
			queue = append(queue, u) // Добавляем вершину в очередь.
		} else {
			m.dist[u] = m.INF // Устанавливаем расстояние как "бесконечность" для остальных.
		}
	}
	m.dist[n] = m.INF // Устанавливаем расстояние для фиктивной вершины (dummy).

	// Выполняем BFS.
	for len(queue) > 0 {
		u := queue[0]   // Берём первый элемент из очереди.
		queue = queue[1:] // Удаляем его из очереди.

		if u < n { // Проверяем, что u не является фиктивной вершиной.
			// Проходим по всем вершинам правой части.
			for v := 0; v < n; v++ {
				if m.graph[u][v] != 0 { // Если есть ребро между u и v.
					if m.pairV[v] == -1 {
						// Если вершина v свободна и еще не достигнута, обновляем dist[n].
						if m.dist[n] == m.INF {
							m.dist[n] = m.dist[u] + 1
						}
					} else if m.dist[m.pairV[v]] == m.INF {
						// Если вершина v уже сопоставлена, обновляем расстояние для пары вершины v.
						m.dist[m.pairV[v]] = m.dist[u] + 1
						queue = append(queue, m.pairV[v]) // Добавляем пару вершины v в очередь.
					}
				}
			}
		}
	}

	// Если расстояние до фиктивной вершины обновилось, существует путь увеличения.
	return m.dist[n] != m.INF
}

// Метод dfs выполняет поиск в глубину для нахождения путей увеличения.
// Вход: текущая вершина u, массив цветов, размер графа.
// Выход: true, если найден путь увеличения через u, иначе false.
func (m *BipartiteMatcher) dfs(u int, color []int, n int) bool {
	if u != n { // Если u не является фиктивной вершиной.
		// Проходим по всем вершинам правой части.
		for v := 0; v < n; v++ {
			if m.graph[u][v] != 0 { // Если есть ребро между u и v.
				// Проверяем, можно ли сопоставить v с u либо v свободна, либо можно найти альтернативный путь для пары v.
				if m.pairV[v] == -1 || (m.dist[m.pairV[v]] == m.dist[u]+1 && m.dfs(m.pairV[v], color, n)) {
					m.pairU[u] = v    // Сопоставляем u с v.
					m.pairV[v] = u    // Сопоставляем v с u.
					return true       // Путь найден.
				}
			}
		}
		m.dist[u] = m.INF // Устанавливаем расстояние как "бесконечность", если путь не найден.
		return false        // Путь не найден.
	}
	return true // Если u является фиктивной вершиной, путь найден.
}

// Метод HopcroftKarp выполняет основной алгоритм поиска максимального паросочетания.
// Вход: массив цветов вершин, размер графа.
// Выход: размер максимального паросочетания.
func (m *BipartiteMatcher) HopcroftKarp(color []int, n int) int {
	// Инициализируем все пары как свободные (-1).
	for i := 0; i < n; i++ {
		m.pairU[i] = -1
		m.pairV[i] = -1
	}

	result := 0 // Счётчик размера паросочетания.

	// Пока существует путь увеличения, увеличиваем паросочетание.
	for m.bfs(color, n) {
		// Проходим по всем вершинам левой части графа.
		for u := 0; u < n; u++ {
			// Если вершина свободна и она левой части графа.
			if color[u] == 0 && m.pairU[u] == -1 {
				// Если можно найти путь увеличения через u.
				if m.dfs(u, color, n) {
					result++ // Увеличиваем размер паросочетания.
				}
			}
		}
	}
	return result // Возвращаем размер максимального паросочетания.
}

// Функция main является точкой входа в программу.
func main() {
	// Определяем флаг -o для задания имени выходного файла.
	output := flag.String("o", "output.txt", "Имя выходного файла")
	flag.Parse() // Парсим аргументы командной строки.

	// Проверяем, указан ли обязательный аргумент (имя входного файла).
	if flag.NArg() < 1 {
		log.Fatal("Необходимо указать имя входного файла")
	}

	inputFile := flag.Arg(0) // Получаем имя входного файла.
	outputFile := *output    // Получаем имя выходного файла из флага.

	// Читаем граф из входного файла.
	graph, n, err := readGraph(inputFile)
	if err != nil {
		log.Fatalf("Ошибка при чтении файла: %v", err)
	}

	// Проверяем, является ли граф двудольным.
	bipartite, color := isBipartite(graph, n)

	// Создаём или открываем выходной файл для записи результатов.
	outFile, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("Не удалось создать выходной файл: %v", err)
	}
	defer outFile.Close() // Закрываем файл при выходе из функции.

	if !bipartite {
		// Если граф не двудольный, записываем соответствующее сообщение и завершаем работу.
		_, err = fmt.Fprintln(outFile, "Граф не является двудольным")
		if err != nil {
			log.Fatalf("Ошибка при записи в файл: %v", err)
		}
		return
	}

	// Если граф двудольный, ищем максимальное паросочетание с помощью Hopcroft-Karp.
	matcher := NewBipartiteMatcher(graph, n)
	matchSize := matcher.HopcroftKarp(color, n)

	// Собираем информацию о паросочетании для вывода.
	matchingEdges := []string{}
	for u := 0; u < n; u++ {
		v := matcher.pairU[u] // Получаем пару для вершины u.
		if v != -1 {          // Если вершина u сопоставлена.
			matchingEdges = append(matchingEdges, fmt.Sprintf("(%d, %d)", u, v)) // Добавляем ребро в список.
		}
	}

	// Записываем результаты в выходной файл.

	// Сообщаем, что граф является двудольным.
	_, err = fmt.Fprintln(outFile, "Граф является двудольным")
	if err != nil {
		log.Fatalf("Ошибка при записи в файл: %v", err)
	}

	// Записываем размер максимального паросочетания.
	_, err = fmt.Fprintf(outFile, "Число паросочетаний: %d\n", matchSize)
	if err != nil {
		log.Fatalf("Ошибка при записи в файл: %v", err)
	}

	// Записываем сами ребра паросочетания.
	_, err = fmt.Fprintln(outFile, "Ребра паросочетания:")
	if err != nil {
		log.Fatalf("Ошибка при записи в файл: %v", err)
	}

	for _, edge := range matchingEdges {
		_, err = fmt.Fprintln(outFile, edge) // Записываем каждое ребро в отдельной строке.
		if err != nil {
			log.Fatalf("Ошибка при записи в файл: %v", err)
		}
	}
}
