# Алгоритм Хопкрофта-Карпа для поиска максимального паросочетания

## Описание

Данная программа реализует **алгоритм Хопкрофта-Карпа** для нахождения **максимального паросочетания** в двудольном графе. Граф задается в виде матрицы смежности, считываемой из бинарного файла. Программа принимает имя входного файла в качестве обязательного параметра и, опционально, имя выходного файла с помощью ключа `-o`. Если имя выходного файла не указано, результаты записываются в файл `output.txt` по умолчанию.

### Основные возможности программы:

1. **Проверка двудольности графа**.
2. **Нахождение максимального паросочетания** в двудольном графе с использованием алгоритма Хопкрофта-Карпа.
3. **Вывод величины паросочетания**.
4. **Отображение списка ребер**, входящих в паросочетание.

## Требования

- **Компилятор Go**: Версия 1.13 или выше.
- **Операционная система**: Windows, Linux, macOS или любая другая ОС с поддержкой Go.

## Сборка

1. **Скачайте исходный код** программы и сохраните его в файл, например, `hopcroft_karp.go`.

2. **Установите Go**, если он ещё не установлен. Следуйте официальной [инструкции по установке Go](https://golang.org/doc/install).

3. **Откройте терминал** или командную строку и перейдите в директорию с исходным кодом.

4. **Скомпилируйте программу** с помощью команды `go build`:

   ```bash
   go build -o hopcroft_karp hopcroft_karp.go
   ```

   Где `hopcroft_karp.go` — имя файла с исходным кодом, а `hopcroft_karp` — имя создаваемого исполняемого файла.

## Использование

Запустите программу, передав в качестве обязательного аргумента имя входного бинарного файла. Опционально можно указать имя выходного файла с помощью ключа `-o`.

### Синтаксис

```bash
./hopcroft_karp <input_file.bm> [-o <output_file.txt>]
```

- `<input_file.bm>`: Имя входного бинарного файла, содержащего матрицу смежности графа.
- `-o <output_file.txt>`: (Опционально) Имя выходного текстового файла. Если ключ `-o` не указан, результаты записываются в файл `output.txt` по умолчанию.

### Пример использования

**Без указания выходного файла (результаты будут записаны в `output.txt`):**

```bash
./hopcroft_karp graph.bm
```

**С указанием выходного файла:**

```bash
./hopcroft_karp graph.bm -o results.txt
```

### Интерфейс пользователя

После запуска программы, она автоматически считывает граф из указанного файла, проверяет его на двудольность и, если граф двудольный, выполняет поиск максимального паросочетания. Результаты записываются в выходной файл.

## Формат входного файла

Входной файл должен быть бинарным и содержать матрицу смежности графа с 16-битными целыми числами (`int16`). Структура файла следующая:

1. **Первое число (`int16`)**: Размер матрицы `n` (количество вершин в графе).
2. **Далее следует `n x n` чисел (`int16`)**: Элементы матрицы смежности. Если элемент равен `0`, предполагается отсутствие ребра между соответствующими вершинами.

### Пример создания бинарного файла

Вот пример того, как можно создать бинарный файл с матрицей смежности на языке Go:

```go
package main

import (
	"encoding/binary"
	"fmt"
	"os"
)

func main() {
	size := int16(4) // Размер матрицы (4 вершины)

	// Матрица смежности (4x4)
	// Пример двудольного графа:
	// U = {0, 1}, V = {2, 3}
	// Ребра: 0-2, 0-3, 1-2
	matrix := []int16{
		0, 0, 1, 1, // Вершина 0 соединена с 2 и 3
		0, 0, 1, 0, // Вершина 1 соединена с 2
		1, 1, 0, 0, // Вершина 2 соединена с 0 и 1
		1, 0, 0, 0, // Вершина 3 соединена с 0
	}

	file, err := os.Create("graph.bm") // Создаём бинарный файл
	if err != nil {
		fmt.Println("Не удалось создать файл:", err)
		return
	}
	defer file.Close()

	// Записываем размер матрицы
	err = binary.Write(file, binary.LittleEndian, size)
	if err != nil {
		fmt.Println("Не удалось записать размер матрицы:", err)
		return
	}

	// Записываем матрицу смежности
	for _, val := range matrix {
		err = binary.Write(file, binary.LittleEndian, val)
		if err != nil {
			fmt.Println("Не удалось записать матрицу смежности:", err)
			return
		}
	}

	fmt.Println("Бинарный файл graph.bm успешно создан.")
}
```

Этот код создаст бинарный файл `graph.bm`, содержащий двудольный граф с 4 вершинами и заданными ребрами.

## Формат выходного файла

Выходной файл представляет собой текстовый файл, содержащий следующую информацию:

1. **Является ли граф двудольным:**

   ```
   Граф является двудольным
   ```

   Или

   ```
   Граф не является двудольным
   ```

2. **Число паросочетаний (для двудольного графа):**

   ```
   Число паросочетаний: <matchSize>
   ```

3. **Ребра, входящие в паросочетание (для двудольного графа):**

   ```
   Ребра паросочетания:
   (u, v)
   (u, v)
   ...
   ```

### Пример выходного файла

```
Граф является двудольным
Число паросочетаний: 2
Ребра паросочетания:
(0, 2)
(1, 3)
```

## Функциональность

- **Чтение из файла:** Программа открывает бинарный файл, считывает размер матрицы и саму матрицу смежности графа.

- **Проверка двудольности:** Используется BFS для проверки, можно ли раскрасить граф в два цвета без конфликтов. Если граф не двудольный, дальнейшие шаги пропускаются.

- **Выполнение алгоритма Хопкрофта-Карпа:** Если граф двудольный, применяется алгоритм Хопкрофта-Карпа для нахождения максимального паросочетания.

- **Запись результатов:** Результаты (является ли граф двудольным, число паросочетаний, список ребер паросочетания) записываются в указанный выходной файл.

- **Освобождение памяти:** После завершения работы, программа освобождает выделенную память.

## Структура данных

- **Edge:** Представляет ребро в графе с конечной вершиной, весом и указателем на следующее ребро в списке смежности.

- **Graph:** Представляет граф с использованием списков смежности и содержит общее количество вершин.

- **MSTEdge:** Представляет ребро в минимальном остовном дереве, включая начальную и конечную вершины и вес ребра.

- **DisjointSetUnion:** Реализует структуру данных "Система непересекающихся множеств" (Union-Find) с оптимизациями по рангу и сжатию путей для эффективного объединения и поиска компонентов.

- **BipartiteMatcher:** Реализует алгоритм Хопкрофта-Карпа для поиска максимального паросочетания в двудольном графе.

## Алгоритм Хопкрофта-Карпа

Алгоритм Хопкрофта-Карпа выполняется следующим образом:

1. **Инициализация:** Все пары вершин устанавливаются как свободные.

2. **Поиск уровневого графа (BFS):** Используется BFS для построения уровневого графа, который помогает найти несколько аугментирующих путей одновременно.

3. **Поиск аугментирующих путей (DFS):** Используется DFS для поиска всех возможных аугментирующих путей в построенном уровневом графе.

4. **Увеличение паросочетания:** Каждое найденное паросочетание добавляется к общему паросочетанию.

5. **Повторение:** Процесс повторяется до тех пор, пока больше не удается найти аугментирующие пути.

## Тесты

Тестовые файлы находятся в папке `tests`. В этой папке вы найдете примеры бинарных файлов с графами различных типов, включая двудольные и недвудольные графы. Эти тесты помогут проверить корректность работы программы.

### Пример использования тестов

1. **Перейдите в папку с тестами:**

   ```bash
   cd tests
   ```

2. **Запустите программу с одним из тестовых файлов:**

   ```bash
   ../hopcroft_karp test1.bm -o result1.txt
   ```

3. **Просмотрите результаты в выходном файле:**

   ```bash
   cat result1.txt
   ```

## Пример использования

### Создание бинарного файла

Используйте приведённый выше пример на Go для создания бинарного файла `graph.bm`.

### Запуск программы

```bash
./hopcroft_karp graph.bm -o results.txt
```

### Пример вывода в `results.txt`

```
Граф является двудольным
Число паросочетаний: 2
Ребра паросочетания:
(0, 2)
(1, 3)
```